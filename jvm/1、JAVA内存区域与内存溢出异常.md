# JAVA内存区域与内存溢出异常

##	1.  运行时数据区域

### 1.1 线程私有

####	1.1.1 程序计数器（Program Counter Register）

​		是一块较小的内存空间，是当前线程所执行的字节码的行号指示器。

​		Java虚拟机多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，一个处理器（多核处理器来说就是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器,独立存储，互不影响，这里内存区域为“线程私有”的内存。

​		如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Naive方法，则计数器为空（Undefined）;这个内存区域是唯一一个不会出现OutOfMemoryError 异常。

####	1.1.2  Java虚拟机栈（Java Virtual Machine Stack）

​	线程私有，生命周期与线程相同。每个方法执行时，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。方法创建到结束对应着栈帧在虚拟机栈中的入栈到出栈的过程。

​		《Java虚拟机规范》中，对于此内存区域规定了两种类异常状况：

* 线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常；

* 虚拟机栈容量可以[^动态扩展]，当栈扩展无法申请到足够的内存会抛出OutOfMemoryError异常；


####	 1.1.3 本地方法栈（Native Method Stack）

​		与虚拟机栈的作用非常相似，区别是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

​		本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError 和 OutOfMemoryError异常；

###	1.2 线程共享

#### 1.2.1  Java堆 （Java Heap）

​		虚拟机所管理的最大的内存，被所有线程共享的内存区域，在虚拟机启动时创建。堆的唯一目的是存放对象实例，**“几乎”**所有的对象实例以及数组都在对在这里分配内存。（由于及时编译技术的进步，尤其是逃逸分析技术的发展，栈上分配、标量替换等优化手段导致了一些些微妙的变化）。

​		从回收内存的角度看，由于现代垃圾回收器大部分都是基于分带收集理论设计的（G1出现之前），都需要新生代、老年代收集器搭配才能完成工作。

​		从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Tread Local Allocation Buffer ，TLAB），以提升对象分配的效率。

​		根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上他应该是连续的。但是对于大对象（如：数组对象），多数虚拟机实现处于简单、存储高效的考虑，很可能会要求连续的空间。

​		Java堆可以实现为固定大小，也可以实现为可扩展的，主流的虚拟机都是按照可扩展来实现的（通过参数-Xmx 和-Xms设定），如果Java堆中没有内存完成实例内存分配，并且堆无法在扩展，虚拟机将会抛出OutOfmemoryError异常。

####	1.2.2  方法区（Method Area）

​		所有线程共享的内存区域，主要用于存储已被虚拟机加载的类的信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

​		JDK8之前，方法区常被开发人员称为**“永久代”（Permanent Generation）** ，两者并不等价，只是使用永久代来实现方法区而已，仅仅是HotSpot（BEAJRockit、IBM J9 没有永久代的概念）设计团队为了方法区能像Java堆一样使用垃圾收集器来管理这块内存,这种设计导致了Java应用更容易遇到内存溢出的问题（-XX:MaxPermSize设置永久代的上限，有默认值，而J9和JRockit只要没有超过进行的可用内存上限，就没问题如32位系统的4GB限制）。JDK7将原本存放在永久代的字符串常量池、静态变量等移出，JDK8使用本地内存（Native Memory）实现元空间替代永久代，讲JDK7中永久代剩余的内容(主要是类型信息)移到元空间。

​		《Java虚拟机规范》对方法区的约束比较宽松，不需要连续的内存以及可以选择固定大小或者可扩展，甚至可以选择不实现垃圾收集。这区域的内存回收主要是针对常量池的回收和对类型的卸载（条件极为苛刻）。

​		如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

#### 1.2.3 运行时常量池 （Runtime Constant Pool）

​		属于方法区的一部分，Class文件中除了有类的版本、字段、方法、接口描述信息外，还有一项信息是常量池表（Constant Pool Table）,用于存放编译期生成的各种字面量与符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。

​		《Java虚拟机规范》对于运行时常量池被没有做任何细节要求，一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。

​		常量并不一定在编译期产生，运行期间也可以将新的常量放入池中（常被开发人员使用的String的intern（）方法）。

​		常量池无法再申请到内存时会抛出OutOfMemoryError异常。

### 1.3 Other

#### 1.3.1 直接内存 （Direct Memory）

​		不是虚拟机运行时数据区的一部分，但是这部分内存也频繁的使用，也会导致OutOfMemoryError异常。

​		JDK1.4中新加入NIO（New Input/Output）类，引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它使用Native函数库直接分配堆外内存，然后通过一个存储在java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样内在一些场景中提升性能，因为避免了在Java堆和Native堆中来会复制数据。

​		本地内存内存的分配不会受Java堆大小限制，但是会受到本机总内存的大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会跟据实际内存去设置-Xmx 等参数的，会忽略掉本地内存，使得各个内存区域综合大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。

###	1.4 内存模型

####	1.4.1 Java 1.6及之前

![image-20201212141106557](https://raw.githubusercontent.com/LeoMao0808/weekly-notes/4b8ba1850139f1293e166bc6ad3f76794cddae3a/resource/jvm-imgs/image-20201212141106557.png)

#### 1.4.2 Java 1.7

![image-20201212141136752](https://raw.githubusercontent.com/LeoMao0808/weekly-notes/4b8ba1850139f1293e166bc6ad3f76794cddae3a/resource/jvm-imgs/image-20201212141136752.png)

####	1.4.3 Java 1.8

![image-20201212141435330](https://raw.githubusercontent.com/LeoMao0808/weekly-notes/4b8ba1850139f1293e166bc6ad3f76794cddae3a/resource/jvm-imgs/image-20201212141435330.png)

##	2. 虚拟机对象

###	2.1 对象创建

#### 2.1.1 对象创建的过程

​		当虚拟机执行new指令的字节码时，首先将去检查这个指令的参数是否能在运行时常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有必须先执行类加载的过程。

​		类加载检查通过后，虚拟机将新生对象分配内存。对象所需内存大小在类加载完成后便可完全确定，对象分配内存的两种方式如下：

1. **指针碰撞（Bump The Pointer）**：Java堆内存绝对规整，所有使用过的内存都放在边，空闲的内存被放在另一边，中间放着指针作为分界点的指示器，分配内存就及仅仅是指针向空闲空间方向挪动一段于对象大小相等的距离。
2. **空闲列表（Free List）**： Java堆内存并不规整，已被使用的内存和空闲的内存相互交错，虚拟机需要维护一个列表，记录那些内存块可用，再分配的时候从列表中找到足够大的空间分配给对象，并更新列表的记录。

​		选择哪种分配方式取决于Java堆内存是否规整，而Java堆内存是否规整又取决于所使用到的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。如使用到Serial、PreNew等待有压缩整理过程的收集器时，采用指针碰撞的分配方式（简单、高效）；而当使用CMS基于清除（Sweep）算法的收集器时，理论上[^一]是只能采用空闲列表来分配内存的。

​		对象创建是非常频繁的行为，在并发的情况下并不是线程安全的，例如：可能在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。结决这个问题有两种可选的方案：

1. **对分配内存空间的动作进行同步处理(实际上虚拟机是采用CAS配上失败重试的方式来保证更新操作的原子性)；**
2. **把内存分配的动作按照线程划分在不同的空间中进行操作，即每个线程在Java堆中预先分配一块内存称为本地线程分配缓冲（Thread Local Alloction Buffer，TLAB）。**（这样那个线程要分配内存，就在当前线程的本地线程缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定）；

​		分配完内存后，虚拟机必须将分配到内存空间（不包括对象头）都初始化为零值。如果使用TLAB则提前至TLAB分配时进行。这步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用（访问到零值）。

​		之后，虚拟机对对象进行必要的设置（例如：对象属于那个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息），这些信息存放在对象头中。

​		完成以上步骤，从虚拟机角度看新对象已经产生。但是从Java程序角度看，对象创建还需调用构造函数（即Class文件中的<init>()方法）去按照开发人员的意愿对对象进行初始化，这样一个对象才算完全被构造出来。

###		2.2 对象的内存布局

​		对象在对内存中的存储布局可划分为三部分：**对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）**。

####	2.2.1 对象头（Header）

对象头部分主要包括两类信息：

1. 用于存储对象自身运行时数据（**如：哈希码（HashCode）、GC年龄分代、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等**），这部分数据被称为**”Mark Word“**（未开启压缩指针的情况下，长度在32位和64位虚拟机中分别对应32比特和64比特）。

   对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额 外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志 位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。 

![img](https://img-blog.csdn.net/20151217151455512?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



2. 类型指针（即对象指向它的类型元数据的指针），虚拟机以此确定该对象是哪个类的实例。并不是所有的虚拟机的实现都必须在对象数据上保留类型指针，但是如果是数组对象必须在对象头中记录数据对象的长度（因为虚拟机可以从对象的元数据信息确定Java对象的大小，但是如果数组长度不确定，将无法通过元数据中的信息确定数组的大小）。

####	2.2.2  实例数据（Instance Data）

​		记录程序代码中所定义的各种类型字段内容（无论是继承父类的，还是子类中定义的字段）。存储顺序受：**-XX:FieldsAllocationStyle**和字段在Java源码中定义的顺序的影响。HotSpot虚拟机默认分配顺序为:longs/doubles、ints、shorts/chars、bytes/booleans 、oops(Ordinary Object Pointers,OOPs),相同宽度的字段 分配在一起，父类的字段会在子类的前面。

####	2.2.3  对齐填充（Padding）

​		不是必然存在的，也没特殊含义，就是占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象其起始地址必须是8字节的整数倍（任何对象的大小都必须是8字节的整数倍）。对象头部分被精心设计为8字节的倍数,如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

###	2.3 对象的访问定位

####	2.3.1 句柄访问对象

​		Java堆中将可能划分出一块内存用来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含对象的实例数据以及类型数据各自具体的地址信息。

![image-20201214124740312](https://raw.githubusercontent.com/LeoMao0808/weekly-notes/4b8ba1850139f1293e166bc6ad3f76794cddae3a/resource/jvm-imgs/image-20201214124740312.png)

####	2.3.2 直接指针访问对象

​		Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，referece中存储的直接就是对象地址，如果只访问对象本身的话，就不需要多一次间接访问的开销。

![image-20201214125107781](https://raw.githubusercontent.com/LeoMao0808/weekly-notes/4b8ba1850139f1293e166bc6ad3f76794cddae3a/resource/jvm-imgs/image-20201214125107781.png)

####	2.3.3 优缺点

1. 使用句柄访问的最大的好处就是referece中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄池中的实例数据指针，而referece本身不需要修改。

2. 使用直接指针来访问最大的好处就是速度快，还节省了一次指针定位的时间开销。由于对象访问在Java中是比较频繁的，积少成多也是比较可观的执行成本。

   HotSpot虚拟机主要使用直接指针访问对象，也有例外的情况如Shenandoah收集器的话也会多一次额外的转发，但从软件开发整体范围看，各种语言、框架中使用句柄来访问的情况也十分常见。

[^一]: “理论上”是因为CMS实现里，为了能在多数情况下分配的更快，设计了一个叫作Linear Allocation Buffer的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在这块大的内存中仍然可以使用指针碰撞来分配。
[^动态扩展]: 动态扩展 Htop虚拟机的栈容量不可以动态扩展 ↩

