#	垃圾收集器与内存分配策略

##	1.1 对象已死？

###	 1.1.1 	引用计数算法

​		**基本原理：**在对象中添加一个引用计数器，被引用计数器值加一；当引用失效，计数器值就减一；任何时刻对象的计数器值为零，该对象就是不可能再被使用的。

​		**优缺点：**原理简单，判定效率高。算法看似简单，但是需要考虑很多例外的情况，必须配合大量额外处理才能保证正确的工作（例如：对象间相互引用的问题）。

###	1.1.2	可达性分析算法

​		**基本原理：**通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始根据引用关系向下搜索，搜索过程所走过对的路径称为“引用链(Reference Chain)",如果该对象到GC Roots间没有任何引用链相连，或者是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

####	1.1.2.1 Java技术体系里的GC Roots

1.	虚拟机栈（栈帧中的局部变量表）中引用的对象（譬如：各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等）；

  2.	方法区中的类静态属性引用的对象（譬如：Java类的引用类型静态变量）；
  3.	方法区中常量引用的对象（譬如：字符串常量池里的引用）；
  4.	本地方法栈中JNI（Native方法）引用对象；
  5.	Java虚拟机内部的引用（譬如：基本数据类型对应的Class对象，一些常驻的异常对象，还有类加载器）；
  6.	所有被同步锁（synchronized关键字）持有的对象；
  7.	反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等；

###  1.1.3  Java中的引用

​		在JDK 1.2版之后，Java对引用概念进行扩充，将引用分为**强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）**四种，四种的强度逐渐减弱。

* **强引用：**指在程序代码中普遍存在的引用赋值（例如：Object obj = new Object（）），无论任何情况下，只要强引用存在，垃圾收集器就永不回收被引用的对象；
* **软引用：**用来描述一些还有用，但不是必须的对象。在系统将要发生内存溢出异常前，会把只被软引用关联的对象列进回收范围之中进行第二次回收，如果内存还不够才会抛出内存溢出异常。在JDK 1.2之后提供Soft Reference类来实现软引用；
* **弱引用:**也是用来描述那些非必须对象，比软引用更弱些，在系统垃圾收集器开始工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。在JDK 1.2 版之后提供Weak Reference来实现弱引用；
* **虚引用：**也称为“幽灵引用”或“幻影引用”，最弱的一种引用关系，为对象设置虚引用的唯一目的是在对象被回收的时会受到一个系统通知。在JDK 1.2版之后提供了Phantom Reference类来实现虚引用；

### 1.1.4  生存or死亡

​	宣告一个对象的死亡，至少要经历两次标记过程：

1. 对象在进行可达性分析后发现没有与GC Roots相连接的应用链，将会被标记一次；

   然后会进行一次筛选，筛选条件是此对象是否有必要执行finalize（）方法。假如对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，这些会被视为没有必要执行。

2. 如果确定要执行finalize（），对象将会被放置到F-Queue的队列中并由一条虚拟机自动建立的、低调度优先级的Finalizer线程去执行他们的finalize（）方法，收集器会对F-Queue中的对象进行二次小规模标记。

   我们可以在第二次标记之前也就是在执行对象的finalize（）时候，重新与引用链上的对象建立关联即可。

   当然这个方法我们要尽量避免使用，因为它的运行代价高且不确定性大，我们可以使用try-finally来替代finalize（）要做的工作。

### 1.1.5 回收方法区

​	方法区的垃圾收集主要包括两部分内容：废弃的常量和不再使用的类型。常量是否被回收与堆中的对象十分相似，但类型回收的条件比较苛刻。需要同时满足下面三个条件：

* 该类的所有的实例都已经被回收，也就是指Java堆中不存在该类的实例及其任何派生子类的实例。
* 加载改类的类加载器已经被回收。（如OSGI、JSP的重加载）
* 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

满足这三个条件后，关于类型是否被回收使用-Xnoclassgc控制，查看类加载和卸载信息：-verbose:class

和-XX:+TraceClassLoading、-XX:+TraceClassUnLoading。-verbose:class和-XX:+TraceClassLoading可以再Product版虚拟机中使用，-XX:+TraceClassUnLoading参数需要在Fast Debug版的虚拟机中使用。

## 1.2 垃圾收集算法

​		从如何判定对象消亡的角度出发，垃圾收集算法可以划分为：**“引用计数式垃圾收集（Reference Counting GC）”**和**“追踪式垃圾收集（Tracing GC）**。这两类也常被称为”直接垃圾收集“和”间接垃圾收集“。主要介绍下追踪式垃圾收集。

### 1.2.1 分代收集理论（Generational Collection）

​		分代收集建立在两个分代假说之上：

1. 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的；
2. 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡；

​        这两个分代假说奠定了很多常见的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，

然后将回收对象依据年龄分配到不同的区域存储。当然分代收集不仅仅是简单的划分下内存区域，还需要考虑对象跨代引用的问题。

​	假如现在进行一次新生代收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，要找出老年代中存活的对象，就需要在固定的GC Roots外追加上老年代的所有对象来确保可达性分类的正确性，相反（理论上老年代的对象被新生代引用）也一样，遍历整个老年代的所有对象，会给内存回收带来很大的性能负担。为了解决该问题添加了第三条假说：

1. 跨代引用假说（Intergenerational Reference Hypothesis ）：跨代引用相对于同代引用来说仅占极少数；

  **方案：**在新生代上建立一个全局的记忆集（Remembered Set，Hot Spot中使用的是“卡表（card Table）”是记忆集的一种实现）的数据结构，把老年代分为若干小块，并标识出那块内存存在跨代引用，发生Minor GC时会把包含有跨代引用的内存里的对象加入到GC Roots进行扫描（Hot Spot卡表中的数据是使用写屏障来维护的）。

![image-20201215201749467](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20201215201749467.png)

### 1.2.2 标记-清除算法（Mark-Sweep）

​		**MS算法执行过程：**主要分为“标记”和“清楚”两个阶段，标记出需要回收的对象（也可以反之），标记完成后统一回收需要回收的对象。

​        **MS算法的两个缺点：**

1. 执行效率不确定：如果Java堆包含大量对象，而且其中大部分需要回收，这时需要大量标记和清除的动作，导致这两个过程的执行效率会随Java堆中的对象数量增长而降低；
2. 内存空间碎片化：经过“标记”和“清除”两个过程后产生大量不连续的内存碎片，空间碎片过多时在分配大对象的时候内存不够会触发垃圾收集动作；

​       **MS算法的示意图：**

### 1.2.3 标记-复制算法

​		**复制算法执行过程：**把内存划分为大小相等两块，每次使用一块。当一块内存不够分配新的对象，将存活的对象的复制到另一块内存，然后把使用过的内存清理掉。（适合存活少的区域使用，存活对象多会导致内存间复制开销过大）分配内存是也不需要考虑有空间碎片，只需要移动堆顶指针，按序分配即可。

​      **复制算法的缺点：**内存使用率低（50%）；

​      **适用场景：**使用新生代内存区域的回收（新生代的对象特点：朝生夕灭）。

​		**“Appel式回收”：**经典的新生代收集器（Serial、PreNew）都采用这种策略来设计内存布局。讲新生代分为较大的Eden区和两块较小的Survivor区，每次只使用Eden区和一块Survivor区。当触发垃圾收集时，将Eden和使用的Survivor区中存活的对象复制到另外一块Survivor空间上，然后直接清理掉Eden和Survivor的空间。（新生代内存的使用率Eden 80%加Survivor 10% ）

**疑问：**如果存活的对象过多导致Survivor区内存不够会发生什么？

​		“Appel式回收”有“逃生门”的安全设计，当Survivor区空间不足以容纳一次Minor GC 存活的对象是，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。

### 1.2.4 标记-整理算法（Mark-Compact）

​		**MC算法执行过程：**主要分为三个阶段"标记"、“移动"和”清除“，标记的过程于”标记-清除“算法一致，第二个阶段是将存活的对象向内存空间一端移动，然后清理掉边界意外的内存。

​		MS算法与MC算法的本质区别在于前者是非移动式回收而后置是移动式。是否移动回收后的存活对象是优缺点并存的风险决策：

  1. 移动对象：老年代每次回收有大量存活对象，移动存活对象并更新所有引用这些对象的地方是一种极为复中的操作，而且移动对象的时候必须停止用户线程[^一]，也就是我们常说的“STOP THE WORLD”[^二]。

  2. 不移动和整理存活对象：内存碎片化的问题只能依赖更为复杂的内存分配器和内存访问器来解决。（譬如内存分配使用"分区空闲分配链表"）

     **总结：** 移动对象内存回收时会更复杂，不移动则分配访问时更复杂。关注停顿时间，不移动对象停顿时间会更短甚至不需要停顿；关注程序吞吐量（即赋值器（“Mutator”，用户程序）与收集器的效率总和）移动对象更划算，内存分配于访问的频率比垃圾回收频率要高的多。(Hot Spot虚拟机里面关注吞吐量的Parallel Scavenge 收集器是基于“标记-整理”算法的，而关注延迟的CMS收集器则是基于“标记-清除”算法的)。

     “和稀泥式”的解决方案[^三]：不再内存分配和访问上增加负担，让虚拟机平时多数使用“标记-清除”算法，直到内存空间的碎片化程度影响到对象分配，在采用“标记-整理”算法收集得到规整的内存空间。

## 1.3 Hot Spot 的算法细节实现

### 1.3.1 根节点枚举

​	**可达性分析算法需要考虑的两点：** 

1. 查找GC Roots的过程如何做到高效，随着Java应用越来越庞大，光方法区的大小就常有数百上千兆，里面的对象更是数不胜数，如果逐个检查会消耗不少时间；
2. 所有收集器在根节点枚举这一环节都必须暂停用户线程，防止分析过程中根节点集合的对象引用关系还在不断变化，保证分析结果的准确性（即时号称停顿时间可控以及几乎不会停顿的CMS、G1、ZGC等收集器，枚举根节点也必须停止用户线程）；

   **解决思路：**我们很自然的想到可以用空间来换取时间，当用户线程停止后收集器不需要一个不漏的检查完所有执行的上下文和全局的引用位置，虚拟机在某个位置（即安全点）把栈以及寄存器上代表引用的位置记录下来，这样在gc发生的时候就不用全部扫描。

   **Hot Spot虚拟机解决方案：**使用一组OopMap的数据结构，一旦类加载动作完成时，虚拟机会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译的过程中，也会在特定位置（安全点）使用记录下栈里和寄存器里那些位置是引用，这样收集器就可以直接获取这些信息。

### 1.3.2 安全点

​	在OopMap的协助下，Hot Spot虚拟机可以快速准确地完成GC Roots枚举，但是我们需要解决这个问题：**如果导致OopMap内容变化的指令非常多，每条指令都生成对应的OopMap,将会需要大量的额外存储空间。**

​    实际上虚拟机并没有为每条指令生成OopMap只是在特定位置记录信息，这些位置便是“安全点（Safe point）”，安全点的设定决定了用户程序执行时并非在代码指令流的任意位置都能停顿下来开始垃圾收集，而是强制必须到达安全点后才能够暂停。所以安全点的选取不能太少也不能太多，太少导致收集器等待时间过长，太频繁会增大运行时的内存负荷。

  安全点的选取标准是：“是否具有让程序长时间执行的特征”，就是指指令序列的复用。例如方法的调用、循环跳转、异常跳转等属于指令的复用，所有只有具有这些才会产生安全点。

   那么如何让所有线程(不包括执行JNI调用的线程)在发生垃圾收集的时候都跑到最近安全点停顿下来：这里有两种方案：

1. **抢断式中断（Preemptive Suspension）：**不需要线程的执行代码主动配合，在发生gc时，系统首先会把所有用户线程全部中断，发现有线程不是在安全点中断，就恢复线程执行到安全点上。（几乎没有虚拟机使用这个方案）
2. **主动式中断（Voluntary Suspension）：** 当发生gc需要中断线程时，设置一个标志位，各个线程执行过程时主动轮询标志，一旦发现标志为真时，就在最近安全点上主动在中断挂起。标识的位置与安全点重合，还需要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生gc，避免没有足够内存分配新对象。

### 1.3.3 安全区域

​    	使用安全点的设计看似完美解决如何停顿用户线程的问题，但是实际上有另外一种情况，当线程没有分配处理器的时间（线程处于Sleep或者Blocked状态），这时线程无法响应虚拟机的中断请求，不能走到安全点中断挂起，虚拟机显然不能等待线程重新被激活分配处理器时间。这种情况必须引入安全区域（Safe Region）来解决。

​		安全区域是指能够确保在某段代码片段总，引用关系不发生变化，在这个区域中任意地方开始垃圾收集都是安全的。（安全区域相当于安全点的延伸）。

​		当用户执行到安全区域里面的代码时，首先会标识自己进入安全区域，这样当虚拟机触发gc就不必去管已经标识过（声明自己在安全区域）的线程。当线程要离开安全区域时，需要检查虚拟机是否完成了根节点枚举（或GC过程中其他需要用户线程停顿的阶段），如果完成了线程直接继续执行，否则线程必须等待，直到收到可以离开安全区域的信号。	

### 1.3.4 记忆集和卡表

​		前面为了解决对象跨代引用，使用了在新生代建立记忆集的数据结构，用来避免将整个老年代加入GC Roots臊面范围。记忆集是一种用于记录从非收集区域指向手机区域的指针集合的抽象数据结构。

​		记录全部含跨代引用对象的实现方案，空间占用和维护成本的代价比较大，在发生GC的时候我们只需要通过记忆集判断出是否有非收集区域指向收集区域的指针，并不需要知道跨代指针的全部细节。我们可以采用粗粒度的记录来节省记忆集的存储和维护成本，下面列举出可供选择的记录精度：

* **字长精度：** 每个记录精确到一个机器字长（指处理器的寻址位数，如常见的32位和64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。
* **对象精度：**每个记录精确到一个对象，该对象里有字段包含跨代指针。
*  **卡精度：**每个记录精确到一块内存区域，该内存区域内有对象含有跨代指针。

​      其中记忆集最常用的一种具体实现是第三种“卡精度”，也是我们常说的“卡表”，卡表定义了记忆集的记录精度、与堆内存的映射关系等。

​		基于卡表的设计，通常将对内存分为大小2的N次幂的卡页（card page）。Hot Spot虚拟机 卡页的是2的9次幂即512字节,卡表（Card Table）被实现为一个简单的字节数组，即卡表的每个标记项为1个字节。

```c
CARD_TABLE [this address >> 9] = 0
```

​		通常一个卡页内存不止包含一个对象，只要卡页内一个或多个对象的字段存在跨代指针，那就将对应卡表的数组的值标识为1，称为这个元素变脏（Dirty），没有标识为0。这样发生GC时，只需要筛选变脏的元素，把它们加入GC Roots中扫描。

### 1.3.5 写屏障

​		Hot Spot 虚拟机中使用写屏障（Write Barrier）技术来维护卡表状态，写屏障可以看做虚拟机层面“引用类型字段赋值”动作的AOP切面，在引用对象时产生一个环形通知，供程序执行额外的动作，赋值前后都在写屏障的覆盖范畴内。赋值前叫做“写前屏障（Pre-Write Barrier），赋值后叫做”写后屏障（Post-Write Barrier）“。（G1出现之前，其他收集器都使用写后屏障）。

```c
void oop_field_store(oop*field,oop new_value) {
	//引用字段赋值操作
	*filed = new_value;
	// 写后屏障，在这里完成卡表状态更新
	post_wrtie_barrier(field,new_value);
}
```

​		应用写屏障后，虚拟机会为所有赋值操作生成相应的命令，一旦收集器在写屏障中增加了更新卡表的操作，无论更新的是不是跨代引用，每次都会对引用进行更新，会产生额外的开销，但这个开销与Minor GC时扫描整个老年代要低很多。

​		卡表在高并发的场景下面临着“伪共享（false Sharing）” 问题，现代中央处理器的缓存系统中是以缓存行（cache Line）为单位存储，当多线程修改互相独立的变量时，如果这些变量恰好共享同一缓存行，就会影响彼此（写回、无效化或者同步）而导致性能降低。

​		为了避免伪共享的问题，使用了一种简单的解决方案：不采用无条件的写屏障，而是先检查卡表标记，只有当卡表元素未被标记过时才将其标记为变脏，卡表更新后逻辑为：

```c
if(CARD_TABLE [this address >> 9] != 0){
	CARD_TABLE [this address >> 9] = 0;
}
```

​		在JDK 7后，Hot Spot 虚拟机增加了一个新的参数：-XX:+UseCondCardMark,用来决定是否开启卡表的更新判断。开启会增加一次额外判断的开销，但是可以避免伪共享问题，两者都有性能损耗，可根据实际情况来权衡是否打开。

### 1.3.6 并发的可达性分析

​		在跟节点枚举这个阶段中，由于GC Roots相比整个Java堆的全部对象相对是少数，且在各种优化技巧（Oop Map）下，停顿时间相对固定，然而在GC Roots往下遍历对象图，这个阶段的停顿时间必定与Java堆的容量成正比例关系：堆越大，存储的对象越多，对象图越复杂，要标记更多对象而产生的停顿时间越长。

​		想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？我们使用三色标记（Tri-color Marking）作为辅助工具来推到，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成三种颜色：

**白色：**表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束阶段，仍然是白色的对象，即代表不可达。

**黑色：**表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色对象代表扫描过，是安全存活的，如果其他对象指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。

**灰色：**表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

​		关于可达性分析的扫描过程，如果用户线程是冻结的，只有收集器线程在工作，那不会有任何问题。但如果用户线程与收集器是并发工作呢？会出现两种后果：一是将原本消亡的对象错误标记为存活，这个还是可以容忍的，下次可以清理掉。另外一种是把原本存活的对象错误标记已消亡，程序会因此报错。



​		当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：

* 赋值器插入了一条或多条从黑色到白色对象的新引用；
* 赋值器删除了全部从灰色对象到白色对象的直接或间接引用；

解决问题的根本在于破坏两个条件的任意一个即可，因此产生两种解决方案：

* **增量更新（Incremental Update）：**破坏第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。（简单理解为将黑色对象在重新插入指向白色对象的引用之后，它就变为灰色对象）
* **原始快照（Snapshot At The Beginning ，SATB）：**破坏第二个条件当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，在将这些记录过的引用关系中的灰色对象为根，重新扫描一次。（简单理解为无论引用关系删除与否，都会按照刚刚开始扫描的那一刻的对象图快照来进行搜索）

以上引用关系的插入或删除，虚拟机的记录操作都是通过写屏障来实现的。在Hot Spot 虚拟机中，这两种方案都有实际应用，譬如,CMS是基于增量更新来做并发标记的,G1 、Shenandoah则是用原始快照来实现的。

## 1.4 经典垃圾收集器

### 1.4.1 Serial收集器

​		Serial收集器是一款新生代收集器，基于标记-复制算法，是一个单线程工作的收集器，这里的单线程并不仅仅是说明它只会使用一个处理器或收集线程去完成垃圾回收工作，更是强调在垃圾回收的时候必须暂停其他所有工作线程。

​		迄今为止，仍然是Hot Spot 虚拟机运行在客户端模式下的默认的新生代收集器，Serial收集器相比其他收集器的单线程更简单高效，且对内存资源受限的环境，是额外内存消耗（Memory Footprint，内存占用）最小的。

​		特点：单线程;实现简单;没有线程交互开销，效率高；内存占用少；

**Serial/Serial Old 收集器运行示意图**

![image-20201224130532403](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20201224130532403.png)

### 1.4.2 ParNew收集器

​		ParNew收集器是Serial收集器的多线程并行版本，其余的行为（如控制参数、STW、分配规则、回收策略等）都与Serial收集器相同。		

​		JDK 5中是使用CMS来收集老年代，新生代只能选择ParNew和Serial收集器中一个[^四]，ParNew收集器时激活CMS（使用-XX:+UseConcMarkSweepGC选项）的默认收集器，也可以使用-XX:-/+UseParNewGC来强制指定或禁用它。

​		-XX:ParallelGCThreads参数来限制垃圾收集的线程数。

​		特点：多线程（垃圾收集线程）并行；

**ParNew/Serial Old收集器运行示意图**

![image-20201224130454166](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20201224130454166.png)

**注意：**

1. 并行（parallel）：描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态；
2. 并发（Concurrent）：描述的是垃圾收集器线程和用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响；

### 1.4.3 Parallel Scavenge 收集器

​		Parallel Scavenge 收集器是一款新生代垃圾收集器，同样基于标记-复制算法实现，也能够并行收集的多线程收集器。

​		CMS等收集器关注的是低延迟（尽可能缩短GC时用户线程停顿的时间）[^五]，而Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量（Throughput）[^六]。所谓的吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值,即：
$$
吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 运行垃圾收集时间)
$$
​		Parallel Scavenge 收集器提供两个参数来精准控制吞吐量：

1. **-XX:MaxGCPauseMillis：**允许值为大于0的毫秒数，收集器将尽力保证内存回收的花费不超过用户设定值。（你这里设定的越小，垃圾收集的速度就会越快，但是这里是拿吞吐量和新生代内存空间为代价的：系统会把新生代调的更小，垃圾收集次数也会越频繁。停顿时间是会降低，但吞吐量也下降了）
2. **-XX:GCTimeRatio：**值应为大于0小于100的整数，即垃圾收集时间占总时间的比率，相当于吞吐量的倒数。（譬如把此参数设置为19，那允许的垃圾收集时间就占总时间的5%（即1/（1+19））,默认值99，即允许最大1%（即1/(1+99））的垃圾收集时间)

​       Parallel Scavenge 收集器还有一个参数**-XX:+UseAdaptiveSizePoicy**，这是一个开关参数，这个参数被激活后，就不需要人工指定新生代大小（-Xmn）、Eden和Survivor去的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调制这些参数以提供最合适的停顿时间或最大吞吐量。这种调节方式称为**垃圾收集的自适应的调节策略（GC Ergonomics）**。我们只需要指定堆的最大值（-Xmx）、最大停顿时间（-XX:MaxGCPauseMillis，更关注停顿时间）、GC时间的比率（-XX:GCTimeRatio，更关注吞吐量）设置优化目标，细节参数又虚拟机自动调节。**自适应调节策略也是Parallel Scavenge 收集器区别于ParNew收集器的重要特性**。

### 1.4.4 Serial Old 收集器

​		Serial Old收集器时Serial收集器的老年代版本，它也是一个单线程收集器，基于标记-整理算法。主要意义也是提供客户端模式下的Hot Spot虚拟机使用。在服务端有两种用途：

1. 在JDK 5以及之前的版本中与Parallel Scavenge 收集器搭配使用[^七]；
2. 作为CMS发生失败的后背预案，在并发发生Concurrent Mode Failure时使用。

### 1.4.5 Parallel Old 收集器

​		Parallel Old 收集器是Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现，且JDK 6才开始提供。

​		在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge 加 Parallel Old 收集器这个组合。

**Parallel Scavenge/Parallel Old 收集器运行示意图**

![image-20201224130421601](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20201224130421601.png)

### 1.4.6 CMS收集器

​		CMS（Concurrent Mark Sweep ）收集器是以获取最短收集停顿时间为目标的收集器，基于标记-清除算法实现，多数应用于互联网站或者B/S系统的服务器端上，这类应用通常比较关注服务的响应速度，让用户有更好的体验。

​		它的运作过程相比前面的收集器更复杂些，整个过程分为四个步骤：

1. **初始化标记（CMS initial mark）：** 需要STW，只是标记一下GC Roots 能直接关联到的对象，速度较快。
2. **并发标记（CMS concurrent mark）：*不需要STW，从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程。
3. **重新标记（CMS remark）：**需要STW，为了修正并发标记期间，因为与用户线程并发运行而导致标记产生变动的那一部分对象的标记记录，CMS使用的是增量更新（这里可以参考1.3.6增量更新的讲解），这个过程通常会比初始标记稍长一些，但是远比并发标记的时间短。
4. **并发清除（CMS concurrent sweep）：**不需要STW，清理删除掉标记阶段判断的已死亡的对象，但不需要移动存活对象。

**CMS 收集器运行示意图**

![image-20201224141337172](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20201224141337172.png)

​		CMS至少有以下三个明显的缺点：

1. **CMS收集器对处理器资源非常敏感；**并发阶段，会降低用户程序的吞吐量。CMS默认启动的回收线程数是（处理器核心+3）/ 4 ,处理器核心数四个以上，并发回收垃圾时垃圾回收线程只占用不超过25%，并且会随着处理器核心数量的增加而下降。但是当处理器核心不足四个时，CMS对用户程序的影响还是很大的。为了解决这个问题提供了“增量式并发收集器（Incremental Concurrent Mark Sweep / i-CMS）”,并发阶段采用垃圾收集线程与用户线程交替运行，避免垃圾收集线程独占资源太久，但是效果很一般。JDK7 i-CMS 被声明为“deprecated”，到JDK 9 发布后i-CMS模式被完全废弃。 
2. **CMS无法处理“浮动垃圾”（Floating Garbage）[^八]；**同时因为CMS在并发标记清理阶段，还需要预留足够的内存给用户线程使用。JDK 5 的默认阈值是老年代使用68%空间就会触发GC，当老年代增长快，可以适当调高参数：**-XX:CMSInitiatingOccu-pancyFraction**的值来提高CMS触发GC的百分比。到JDK 6是默认阈值为92%，但是又会出现另一种风险：“并发失败（Concurrent Mode Failure）”[^九]，这时候虚拟机会启用备选方案冻结用户线程，临时启用Serial Old 收集器来从新进行老年代的垃圾回收，这样停顿时间会更长。
3. **CMS基于标记-清除算法实现，回收结束会产生大量空间碎片；**在分配大对象时老年代有很多剩余空间但是找不到连续的内存空间，会提前导致Full GC 。为了解决这个问题， CMS提供**-XX:+UseCMSCompactAtFullCollection**开关参数（默认开启，JDK 9废弃），用于在不得不进行Full GC时开启内存碎片的合并整理过程，由于需要移动对象无法并发（Shenandoah和ZGC出现以前）。这样内存碎片问题解决了但是停顿时间却变长了，因此又提供了**-XX:CMSFullGCsBeforeCompaction**(JDK 9废弃),执行若干次（数量有参数值决定）不整理空间的Full GC后，下一次进入Full GC 前会先进行内存整理（默认值为0）。

**CMS收集器收集完整步骤：**

- Initial Mark【初始标记】
- Concurrent Mark 【并发标记】
- Concurrent Preclean【并发预先清除】
- Concurrent Abortable Preclean【并发可能失败的预先清除】
- Final Remark【最终重新标记】
- Concurrent Sweep【并发清除】
- Concurrent Reset【并发重置】

### 1.4.7 Garbage First （G1）收集器

​		G1收集器开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。主要面向服务端应用的垃圾收集器。JDK 9 G1 取代了Parallel Scavenge 和 Parallel Old 组合，成为服务端默认垃圾收集器。

**Region**

​		G1收集器开创基于Region的堆内存布局，虽然遵循分代收集理论，但堆内存布局不再是固定大小以及固定数量的分代区域划分，而是把堆分为多个（默认2048个）大小相等Region，每个Region都可以是新生代（e + s0 + s1）、老年代，收集器能对不同的Region采用不同的策略去处理.

​		Region的大小可以使用-XX:G1HeapRegionSize设定，值的范围1 MB ~ 32 MB，且应为2的幂次方。Region 中使用N个连续的Houmongous Region来存储大对象（对象大小超过Region容量一半）。G1的大多数行为都把Humongous Region作为老年代一部分来看待。

**GC模式**

​		G1出现之前的垃圾收集的目标范围：新生代（Minor GC / Young GC）、老年代（Major GC/Old GC）、Full GC 。而G1 则面向整个堆内存任何部分组成回收集，衡量的标准不再是属于那个分代，而是那块内存垃圾数量最多，回收收益最大，这是G1收集器的Mixed GC。

​		G1之所以能建立可预测的停顿时间模型，最主要的原因是：将Region作为单次最小回收单元（每次回收的内存都是Region 的整数倍）。更具体的处理思路是：让G1收集器去跟踪各个Region 垃圾堆积的“价值”（即回收所获得的空间大小及回收所需时间的经验值），在后台维护一个优先级列表，每次根据用户设定的最大收集停顿时间（-XX:MaxGCPauseMillis,默认是200毫秒），优先处理回收价值收益最大的Region。

**G1 收集器 Region 分区示意图**

**G1实现中需要解决的问题**

  * **如何处理Region间的跨代引用？**
    		* 大致的解决思路是：使用记忆集避免整个堆作为GC Roots的扫描，但G1的记忆集的应用要更复杂，每个Region 都维护一个记忆集（这些记忆集会记录下别的Region指向自己的引用，并标记这些指针分别在那些卡页的范围之内）。本质上是哈希表，Key为别的Region 的起始地址，Value是一个集合，存储的元素是卡表的索引号。这种“双向”的卡表结构[^十]，实现起来更复杂，而且Region分区比传统分代需要建立和维护的卡表数量多，内存负担更大(G1至少要消耗Java堆的10%至20%来维持收集器工作)。
  * **并发标记如何保证收集线程与用户线程互不干扰？**
    		* 首先这我们需要回顾下 1.3.6章的知识，解决在并发标记阶段用户线程改变对象引用关系时，必须保证其不能打破原本的对象图结构，导致标记结果出现错误。**CMS收集器采用增量更新算法实现（破坏），G1收集器采用原始快照(STAB)算法实现。**此外，垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序爱要继续运行会持续有新对象产生分配，G1为每个Region 设计两个名为TAMS（Top at Mark Start）的指针，把Region中的部分空间划分出来用于回收新对象分配，且新创建的对象必须在两个指针上面，收集器默认它们是存活的不在回收范围。CMS会发生并发失败（Concurrent Mode Failure ）导致Full GC，G1收集器如果在内存回收速度比内存分配慢的情况下，也要冻结所有用户线程，触发Full GC而产生长时间停顿。
  * **怎么建立可靠的停顿预测模型？**
    		* 用户通过设定-XX:MaxGCPauseMillis参数指定最大收集停顿时间（用户的期望值），G1收集器的停顿 预测模型是以**衰减均值（Decaying Average）为理论基础**来实现的，在垃圾收集过程中，G1收集器会记 录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的**成本**，并分析得 出**平均值、标准偏差、置信度**等统计信息。这里强调的“**衰减平均值**”是指它会比普通的平均值更容易 受到新数据的影响，平均值代表整体平均状态，但衰减平均值更准确地代表“**最近的**”平均状态。换句 话说，**Region**的统计状态越新越能决定其回收的价值。然后通过这些信息预测现在开始回收的话，由 哪些**Region组成回收集**才可以在不超过期望停顿时间的约束下获得**最高的收益**。

**G1收集器的收集过程**

​		G1收集器收集过程大致分为四个步骤：

 * **初始标记（Initial Marking）：** 只是标记下GC Roots能直接关联的对象，并修改TAMS的值，让下阶段用户线程并发运行时，能够在可用的Region中分配新对象。需要STW，但耗时短，而且是借用进行Minor GC时同步完成，所以G1收集器在这个阶段实际上没有额外的停顿。
 * **并发标记（Concurrent Marking）：**从 GC Roots开始对堆中对象进行可达性分析，递归扫描整个堆的对象图，找出需回收对象，此阶段耗时较长，但和用户线程并发执行。当对象图扫描完后，重新处理SATB记录的并发时有引用变动的对象。
 * **最终标记（Final Marking）：**短暂的STW，用于处理并发阶段结束后仍遗留下来的最后少量的SATB记录
 * **筛选回收（Live Data Counting and Evacuation）：**负责更新Region的统计数据，对各个Region 的回收价值和成本进行排序，根据用户期望的停顿时间来选择部分Region组成回收集，然后再把需回收Region中存活的对象复制到空的Region中，再清理掉旧Region的全部空间。因为涉及到对象的移动，必须STW，由多条收集线程并行完成。

**G1收集器运行示意图**

![image-20201228212449140](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20201228212449140.png)

**G1和CMS收集的比较**

​	**优点**

​	G1收集器可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集。从算法理论上看，G1更有发展潜力。CMS采用“标记-清除”算法，而G1整体是基于“标记-整理”算法实现的，而从局部看又是基于“标记-复制”算法实现。这两种算法都不会产生空间碎片，内存规整，有利于程序长时间运行，为大对象分配内存时不容易因无法找到不连续的空间尔提前触发gc。

​	**缺点**

1. **内存占用（Footprint）高；**G1和CMS都使用卡表来处理跨代引用。但G1的卡表实现比较复杂（相当于“双向”卡表），而且堆中每个Region都需要维护一个卡表，导致这些卡表可能会占对容量的10%~20%或更多内存空间。相比之下CMS的卡表实现简单，只有唯一一份，而且只需要记录老年代指向新生代的引用（由于新生代的对象朝生夕灭，引用变化频繁[^十一]）。
2. **执行负载（Overload）高；**譬如CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障来进行更复杂的卡表维护操作外，为了实现原始快照（STAB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。相比起增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。由于G1对写屏障的复杂操作比CMS消耗更多运算资源，，所以CMS的写屏障实现是直接的同步操作，而G1将其实现为类似与消息队列的结构，把写前屏障和写后屏障中要做的事放到队列里，然后再异步处理。

## 1.5 低延迟收集器 

​		衡量垃圾收集器的三项重要的指标是：内存占用（Footprint）、吞吐量（Throughput）、延迟（Latency），三者共同构成“不可能三角”（三元悖【bei】论），

### 1.5.1 Shenandoah 收集器

​		Shenandoah 收集器有着与G1收集器相似的内存布局，在初始标记、并发标记等阶段的处理思路高度一致（甚至直接共享了一部分的实现代码），当然Shenandoah 收集器的新特性，也有部分出现在G1收集器中，譬如在并发失败后作为“逃生门的”的Full GC (JEP 307: Parallel Full GC for G1)，G1也是合并了 Shenandoah 收集器的代码才获得多线程Full GC 的支持。

​		Shenandoah 收集器的改进：虽然基于Region的堆内存布局，同样使用Humongous Region存放大对象，默认的回收策略也同样是优先处理最大的Region，单在管理堆内存方面，有三方面与G1不同：

- **支持并发的整理算法;**
  - G1回收阶段可以多回收线程并行处理，但是不能与用户并发。
- **Shenandoah 收集器目前默认不使用分代收集；**
  - 并不是分代收集对它没有价值，只是出于性价比的权衡，基于工作量上的考虑而将其放到优先级较低的位置上。
- **使用"连接矩阵"（Connection Matrix）的全局数据结构代替了G1中耗费大量内存和计算资源去维护的记忆集（卡表）来记录跨Region的引用关系；**
  - 降低了处理跨带指针时的记忆集的维护消耗，也降低了伪共享的发生概率。连接矩阵可以简单理解为一张二维表格，如果Region N 有对象指向Region M，就在表格 N行M 列标记。在回收时通过这张表格就可以得出Region之间产生的跨Region引用。

**Shenandoah 收集器的连接矩阵示意图**



**Shenandoah 收集器的工作过程**

* **初始化标记（Initial Marking）：**与G1一样，首先标记与GC Roots直接关联对象，需要STW，但停顿时间与堆大小无关，只于GC Roots数量相关。
* **并发标记（Concurrent Marking）：**与G1一样，遍历对象图，标记出全部可达的对象，该阶段可以与用户线程并发执行，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。
* **最终标记（Final Marking）：**与G1一样，处理剩余STAB扫描，并在该阶段统计出回收价值最高的Region，将这些Region构成回收集（Collection Set）。最终编辑阶段也有一小段的停顿。
* **并发清理（Concurrent Cleanup）：**该阶段用于清理那些整个区域内连一个存活对象都没有找到Region（这类Region被称为 Immediate Garbage Region ）。
* **并发回收（Concurrent Evacuation）：**并发回收阶段是与Hot Spot其他收集器的核心差异。该阶段 Shenandoah 要把回收集里面的存活对象先复制一份到其他未使用的Region中。收集线程复制对象和用户线程并发进行，难点是在移动对象时，用户线程仍然可能不停对被移动的对象进行读写访问，移动对象是一次性行为，但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的。这些困难，Shenandoah 将会通过读屏障和被称为“Brooks Pointers”的转发指针来解决。并发回收阶段运行的时间长短取决于回收集大小。
* **初始引用更新（Initial Update Reference）：**并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段并没做具体处理，这个阶段是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务。初始引用更新时间很短，会产生一个非常短暂的停顿。
* **并发引用更新（Concurrent Update Reference）：**真正开始进行引用更新操作，改阶段于用户线程并发进行，时间长短取决于内存中涉及的引用数量的多少。并发引用更新于并发标记不同，不需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。
* **最终引用更新（Final Update Reference）：**解决了堆中的引用更新后，还要修正存在于GC Roots中的引用。这个阶段是Shenandoah 的最后一次停顿，停顿时间只与GC Roots的数量相关。
* **并发清理（Concurrent Cleanup）：**经过并发回收和引用更新之后，整个回收集中所有的Region 已再无存活对象，这些Region 都变成 Immediate Garbage Region 了，最后在调用一次并发清理过程来回收这些Region 的内存空间，供以后新对象分配使用。



**Shenandoah 收集器的并发整理核心概念---Brooks Pointer**

​		1984年 Boorks 首先提出使用转发指针（Forwarding Pointer，也常被称为 Indirection Pointer）来实现对象移动与用户程序并发的一种解决方案。

​		此前，要做类似的并发操作，通常在被移动对象的旧内存地址上设置保护陷阱（Memory Protection Trap）,一旦用户程序访问到旧对象的内存空间就会产生自陷中段，进入预设好的异常处理器中，再由其中的代码逻辑把访问转发到复制后的新对象上。虽然实现了并发，但是需要系统层面的直接支持，这种方案将导致用户态频繁切换到核心态，代价很大，不能频繁使用。

​		Boorks 的新方案不需要用内存保护陷阱，而是在原有对象布局结构的最前面同一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。

**Brooks Pointers 示意图**

​		从结构上看Brooks Pointers与句柄定位有些相似之处，两者都是间接性访问对象的方式，差别在句柄都在专门存储的句柄池中，而转发指针是放在每个对象头前面。

Brooks Pointers的并发问题处理



### 1.5.2 ZGC 收集器



## 1.6 虚拟机参数总结



### 1.6.1 虚拟机日志参数（JDK 9与之前的参数对比）



### 1.6.2 虚拟机垃圾收集常用参数总结

| 参数                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| UseSerialGC                    | Client模式下默认值，打开此开关将使用Serial+Serial Old的收集器组合进行收集 |
| UseParNewGC                    | 使用ParNew+Serial Old的收集器组合进行收集,JDK 9 后不再支持   |
| UseConcMarkSweepGC             | 使用ParNew+CMS+Serial Old的收集器组合进行收集。Serial Old收集器作为CMS发生Concurrent Mode Failure失败后的后备收集器 |
| UseParallelGC                  | JDK 9之前Server模式下的默认值，使用Parallel Scavenge+Serial Old（PS MarkSweep）的收集器组合进行收集 |
| UseParallelOldGC               | 使用Parallel Scavenge+Parallel Old的收集器组合进行收集       |
| SurvivorRatio                  | 新生代中Eden区域和Survivor区域的容量比值，默认为8（ eden ：s = 8 : 1 ） |
| PretenureSizeThreshold         | 直接晋升到老年代的对象大小，大于这个参数的对象将直接分配到老年代 |
| MaxTenuringThreshold           | 晋升代老年代的对象年龄。对象经过一次Minor GC年龄加1，超过这个设置的年龄将进入老年代 |
| UseAdaptiveSizePolicy          | 动态调整Java堆中各个区域的大小以及进入老年代的年龄           |
| HandlePromotionFailure         | 是否允许分配担保失败。老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况 |
| ParallelGCThreads              | 设置并行GC时进行内存回收的线程数                             |
| GCTimeRatio                    | GC时间占总时间的比率，默认99，允许1%的GC时间，仅在使用Parallel Scavenge收集器时生效。 |
| MaxGCPauseMillis               | 设置GC的最大停顿时间，仅在使用Parallel Scavenge收集器时生效。 |
| CMSInitiatingOccupancyFraction | 设置CMS收集器在老年代空间被使用多少货触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效。 |
| UseCMSCompactAtFullCollection  | 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理，仅在使用CMS收集器时生效。（JDK 9后废弃） |
| CMSFullGCsBeforeCompaction     | 设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理，仅在使用CMS收集器时生效。（JDK 9后废弃） |
| UseG1GC                        | 使用G1收集器，JDK 9后的server模式默认值                      |
| G1HeapRegionSize=n             | 设置Region大小，并非最终值                                   |
| MaxGCPauseMillis               | 设置G1收集过程目标时间，默认200 ms，不是硬性条件             |
| G1NewSizePercent               | 新生代最小值，默认5%                                         |
| G1MaxNewSizePercent            | 新生代最大值，默认60%                                        |
| ParallelGCThreads              | 用户线程冻结期间并行执行的收集器线程数                       |
| ConcGCThreads=n                | 并发标记、并发整理的执行线程数，对不同的收集器，根据其能够并发的阶段，有不同的含义 |
| InitiatingHeapOccupancuPercent | 设置触发标记周期的Java堆占用率阈值。默认45%。这里的java堆占比指的是non_young_capacity_bytes,包括old+humongous |
| UseShenandoahGC                | 使用Shenandoah收集器。这个选项在Oracle JDK中不被支持，只能在Open JDK 12或者某些支持Shenandoah的Back port发行版本使用。目前仍要配合 -XX:+UnlockExperimentalVMOptions使用 |
| ShenandoahGCHeuristics         | Shenandoah何时启动一次GC过程，其可选值有adaptive、static、compact、passive、aggressive |
| UseZGC                         | 使用ZGC收集器，目前仍要配合-XX:+UnlockExperimentalVMOptions使用 |
| UseNUMA                        | 启用NUMA内存分配支持，目前只有Parallel 和 ZGC支持，以后G1可能也会支持 |
| UnlockExperimentalVMOptions    | 解锁实验参数，允许使用实验性参数，JVM中有些参数不能通过-XX直接复制需要先解锁，比如要使用某些参数的时候，可能不会生效，需要设置这个参数来解锁； |















[^一]: 最新的ZGC和Shenandoah收集器使用读屏障（Read Barrier）技术实现了整理过程与用户线程的并发执行。
[^二]: 通常“标记-清除”算法也需要停顿用户线程来回收对象，只是停顿时间相对而言比较短而已。
[^三]: 前提到关注延迟的CMS收集器面临碎片化过多时采用这种方法处理。
[^四]: CMS不能和Parallel Scavenge使用的原因：一是关注目标不一致，CMS关注低延迟而PS关注高吞吐量；二是CMS、ParNew、Serial收集器共用了Hot Spot中设计的分代框架的代码，而PS以及G1都没有使用。
[^五]: 停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验。
[^六]: 高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。
[^七]: Parallel Scavenge 收集器架构中本身有PS Mark Sweep 收集器来进行老年代收集，并非直接调用Serial Old 收集器，但是PS Mark Sweep 收集器与Serial Old 收集器实现几乎一样，所有在官方资料中都是直接以Serial Old 代替它讲解。

[^八]: CMS在并发标记和并发清理阶段，垃圾收集线程和用户线程是并发运行的，会有新的垃圾对象不断产生，但这部分垃圾对象出现在标记过程之后的，CMS无法在当前收集中清理掉，只能留到下次垃圾收集时在清理。这部分垃圾称为“浮动垃圾”

[^九]: CMS运行期间预留的内存空间不足以程序分配新对象的需要，就会出现并发失败。

[^十]: 卡表的结构是"我指向谁"即引用内存地址，这种双向卡表还记录了是”谁指向我“。
[^十一]: 代价就是当CMS发生 Major GC的时候会把整个新生代作为GC Roots来进行扫描。